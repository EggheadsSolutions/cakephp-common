# Фичи ORM

## Entity

* Алиасы полей, с которыми можно работать так же, как и с обычными полями. Удобно для случаев, когда в базе есть поля с
  автогенерирующимися названиями, а в коде хотелось бы обращаться к ним по-нормальному. Для создания алиаса в
  массиве `_aliases` добавить пару ключ-значение `'alias' => 'original'`.
  [Генератор сущностей](../EntityBuilder) создаст соответствующие магические свойства. Эти свойства можно читать,
  редактировать, использовать в методах `newEntity`, `patchEntity`, `set`, и они присутствуют при приведении сущности к
  массиву.
* Метод `changed(string $field): bool` - изменилось ли значение поля. Если для поля сделать присвоение исходного
  значения, то `dirty` станет `true`, что не всегда удобно. Внутри делается нестрогое сравнение `==`

```php
$entity->field = $entity->field;
$entity->isDirty('field'); // true
$entity->changed('field'); // false
```

* Метод `deleteChild(string $childEntity, ?int $index = null): void` - удалить дочернюю сущность и проставить `dirty`.
  Пример: есть сущность `$entity` с массивом дочерних сущностей `children`.

```php
unset($entity->children[2]);
$entity->setDirty('children', true); // без этого удаление не произойдёт!
$table->save($entity);

// чтобы не забывать выставлять dirty
$entity->deleteChild('children', 2);
$table->save($entity);
// кстати, при этом нужно сохранять со стратегией SAVE_REPLACE, а не SAVE_APPEND
// об этом подробнее в разделе Table

// если ассоциация hasOne, а не hasMany, то вызывать без второго параметра
```

## Query

* Статические методы `funct` и `expr` - аналоги нестатических `func` и `newExpr`, потому что статические удобнее

## Table

* Для полей `created`, `updated` и `modified` автоматически инициализируется `timestampBehavior`
* Автоматически проставляется класс сущности `setEntityClass()`
* Статический метод `instance()` - замена `TableRegistry::get(string $tableAlias)`, удобно тем, что не используются
  строки, т.е. теперь есть автодополнение, и можно быстро перейти в класс
* Метод `saveArr(array $data, Entity|int|null $entity, array $options): Entity` - сохранение в одно действие, вместо
  вызова связки `get/newEntity, patchEntity, save`. Если задан только первый параметр, то создаёт новую запись в
  таблице. Если второй параметр - сущность, то редактирует её. Если второй параметр - число, то достаёт из базы запись с
  таким ключом и редактирует её.
* Метод `getEntity(Entity|int $entity, array $options): Entity|false`. Работает как `get()`, но не кидает исключений.
  Если вместо ключа передана сущность, то просто возвращает её
* Метод `exists()` прокачан, чтобы можно было использовать `contain`
* Метод `updateWithLock(array|Query $query, array $data): ?Entity` - редактирование с блокировкой. Для одной записи из
  переданного запроса делает `SELECT ... FOR UPDATE` и редактирует её
* Метод `save()` прокачан:
    * если у любой зависимой сущности проставлено `dirty`, то проставляет `dirty` на текущую сущность
    * возможность изменить стратегию сохранения дочерних сущностей в `HasMany` на один вызов `save()`. По умолчанию
      используется `SAVE_APPEND`, и если в списке дочерних сущностей что-то отсутствует, то ничего не происходит. При
      использовании `SAVE_REPLACE` все отсутствующие дочерние сущности удаляются. То есть в обычной ситуации нужно
      оставить `SAVE_APPEND`, а `SAVE_REPLACE` использовать только когда мы хотим удалить дочернюю сущность
      через `save()`. В кейке есть возможность сменить стратегию для таблицы, но так как `SAVE_REPLACE` - это опасная
      штука, то хотелось бы, чтобы после вызова `save()` стратегия переключалась обратно в `SAVE_APPEND`. Что я и
      сделал. В опции метода `save()` я добавил массив `'assocStrategies' => ['assocName' => 'strategy']`
* Метод `truncate(void): bool`: выполняет непосредственно `TRUNCATE`
* `findList` прокачан - вместо `['keyField' => 'f1', 'valueField' => 'f2']` можно передать `['f1' => 'f2']`. Если
  передать просто одно поле `['f1']`, то оно будет и ключом и значением. Если нужно использовать параметр `'groupField'`
  , то нужно писать по-старому. Короткая форма записи ещё и сама вызывает `select()` на переданные поля. Но если нужно
  выбрать значение выражения, то надо вызывать `select()` самому с опцией `overwrite`:

```php
$table->find('list', ['id' => 'expr'])
  ->select([
    'id',
    'expr' => 'какое-то выражение',
  ], true) // <- вот этот true здесь нужен, 2й параметр - overwrite
```

* Метод `query()` возвращает наш `Query`, а не кейковский
* Методы объявления ассоциаций: `hasOne`, `belongsTo`, `hasMany` и `belongsToMany` автоматически проставляют
  параметр `'propertyName'` такой же, как и название ассоциации. Если его не проставлять явно, то кейк его как-то
  преобразует (кажется, будет из множественного числа делать единственное)
